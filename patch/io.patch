diff -u ../avr-libc/trunk/avr-libc/include/avr/iom16m1.h /usr/local/avr/avr/include/avr/iom16m1.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom16m1.h	2010-05-31 09:49:34.220831160 -0400
+++ /usr/local/avr/avr/include/avr/iom16m1.h	2010-07-29 19:12:25.515794082 -0400
@@ -1157,6 +1157,8 @@
 
 #define CANIE1 _SFR_MEM8(0xDF)
 
+#define CANSIT  _SFR_MEM16(0xE0)
+
 #define CANSIT2 _SFR_MEM8(0xE0)
 #define SIT0 0
 #define SIT1 1
@@ -1305,6 +1307,9 @@
 #define CONMOB0 6
 #define CONMOB1 7
 
+/* RegDef:  CAN Identifier Tag Registers*/
+#define CANIDT  _SFR_MEM32(0xF0)
+
 #define CANIDT4 _SFR_MEM8(0xF0)
 #define RB0TAG 0
 #define RB1TAG 1
@@ -1345,6 +1350,9 @@
 #define IDT27 6
 #define IDT28 7
 
+/* RegDef:  CAN Identifier Mask Registers */
+#define CANIDM  _SFR_MEM32(0xF4)
+
 #define CANIDM4 _SFR_MEM8(0xF4)
 #define IDEMSK 0
 #define RTRMSK 2
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom16u4.h /usr/local/avr/avr/include/avr/iom16u4.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom16u4.h	2010-05-31 09:49:34.173204247 -0400
+++ /usr/local/avr/avr/include/avr/iom16u4.h	2010-07-27 19:08:49.465793582 -0400
@@ -561,7 +561,7 @@
 #define ADTS0 0
 #define ADTS1 1
 #define ADTS2 2
-#define ADTS3 4
+#define ADTS3 3
 #define MUX5 5
 #define ACME 6
 #define ADHSM 7
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom32c1.h /usr/local/avr/avr/include/avr/iom32c1.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom32c1.h	2010-05-31 09:49:34.292592181 -0400
+++ /usr/local/avr/avr/include/avr/iom32c1.h	2010-07-29 19:12:55.085796337 -0400
@@ -906,6 +906,8 @@
 
 #define CANIE1 _SFR_MEM8(0xDF)
 
+#define CANSIT  _SFR_MEM16(0xE0)
+
 #define CANSIT2 _SFR_MEM8(0xE0)
 #define SIT0 0
 #define SIT1 1
@@ -1054,6 +1056,9 @@
 #define CONMOB0 6
 #define CONMOB1 7
 
+/* RegDef:  CAN Identifier Tag Registers*/
+#define CANIDT  _SFR_MEM32(0xF0)
+
 #define CANIDT4 _SFR_MEM8(0xF0)
 #define RB0TAG 0
 #define RB1TAG 1
@@ -1094,6 +1099,9 @@
 #define IDT27 6
 #define IDT28 7
 
+/* RegDef:  CAN Identifier Mask Registers */
+#define CANIDM  _SFR_MEM32(0xF4)
+
 #define CANIDM4 _SFR_MEM8(0xF4)
 #define IDEMSK 0
 #define RTRMSK 2
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom32m1.h /usr/local/avr/avr/include/avr/iom32m1.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom32m1.h	2010-05-31 09:49:34.251095586 -0400
+++ /usr/local/avr/avr/include/avr/iom32m1.h	2010-07-29 19:12:10.495795220 -0400
@@ -1180,6 +1180,8 @@
 
 #define CANIE1 _SFR_MEM8(0xDF)
 
+#define CANSIT  _SFR_MEM16(0xE0)
+
 #define CANSIT2 _SFR_MEM8(0xE0)
 #define SIT0 0
 #define SIT1 1
@@ -1328,6 +1330,9 @@
 #define CONMOB0 6
 #define CONMOB1 7
 
+/* RegDef:  CAN Identifier Tag Registers*/
+#define CANIDT  _SFR_MEM32(0xF0)
+
 #define CANIDT4 _SFR_MEM8(0xF0)
 #define RB0TAG 0
 #define RB1TAG 1
@@ -1368,6 +1373,9 @@
 #define IDT27 6
 #define IDT28 7
 
+/* RegDef:  CAN Identifier Mask Registers */
+#define CANIDM  _SFR_MEM32(0xF4)
+
 #define CANIDM4 _SFR_MEM8(0xF4)
 #define IDEMSK 0
 #define RTRMSK 2
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom32u4.h /usr/local/avr/avr/include/avr/iom32u4.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom32u4.h	2010-05-31 09:49:34.220831160 -0400
+++ /usr/local/avr/avr/include/avr/iom32u4.h	2010-07-27 19:23:14.385795307 -0400
@@ -540,7 +540,10 @@
 
 #define TIMSK5 _SFR_MEM8(0x73)
 
-#define ADC _SFR_MEM16(0x78)
+#ifndef _ASSEMBLER_ 
+#define ADC _SFR_MEM16(0x78) 
+#endif 
+#define ADCW _SFR_MEM16(0x78) 
 
 #define ADCL _SFR_MEM8(0x78)
 #define ADCL0 0
@@ -576,7 +579,7 @@
 #define ADTS0 0
 #define ADTS1 1
 #define ADTS2 2
-#define ADTS3 4
+#define ADTS3 3
 #define MUX5 5
 #define ACME 6
 #define ADHSM 7
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom64c1.h /usr/local/avr/avr/include/avr/iom64c1.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom64c1.h	2010-05-31 09:49:34.273207838 -0400
+++ /usr/local/avr/avr/include/avr/iom64c1.h	2010-07-29 19:13:26.877039101 -0400
@@ -907,6 +907,8 @@
 
 #define CANIE1 _SFR_MEM8(0xDF)
 
+#define CANSIT  _SFR_MEM16(0xE0)
+
 #define CANSIT2 _SFR_MEM8(0xE0)
 #define SIT0 0
 #define SIT1 1
@@ -1055,6 +1057,9 @@
 #define CONMOB0 6
 #define CONMOB1 7
 
+/* RegDef:  CAN Identifier Tag Registers*/
+#define CANIDT  _SFR_MEM32(0xF0)
+
 #define CANIDT4 _SFR_MEM8(0xF0)
 #define RB0TAG 0
 #define RB1TAG 1
@@ -1095,6 +1100,9 @@
 #define IDT27 6
 #define IDT28 7
 
+/* RegDef:  CAN Identifier Mask Registers */
+#define CANIDM  _SFR_MEM32(0xF4)
+
 #define CANIDM4 _SFR_MEM8(0xF4)
 #define IDEMSK 0
 #define RTRMSK 2
diff -u ../avr-libc/trunk/avr-libc/include/avr/iom64m1.h /usr/local/avr/avr/include/avr/iom64m1.h
--- ../avr-libc/trunk/avr-libc/include/avr/iom64m1.h	2010-05-31 09:49:34.231648716 -0400
+++ /usr/local/avr/avr/include/avr/iom64m1.h	2010-07-29 19:12:40.985785551 -0400
@@ -1158,6 +1158,8 @@
 
 #define CANIE1 _SFR_MEM8(0xDF)
 
+#define CANSIT  _SFR_MEM16(0xE0)
+
 #define CANSIT2 _SFR_MEM8(0xE0)
 #define SIT0 0
 #define SIT1 1
@@ -1306,6 +1308,9 @@
 #define CONMOB0 6
 #define CONMOB1 7
 
+/* RegDef:  CAN Identifier Tag Registers*/
+#define CANIDT  _SFR_MEM32(0xF0)
+
 #define CANIDT4 _SFR_MEM8(0xF0)
 #define RB0TAG 0
 #define RB1TAG 1
@@ -1346,6 +1351,9 @@
 #define IDT27 6
 #define IDT28 7
 
+/* RegDef:  CAN Identifier Mask Registers */
+#define CANIDM  _SFR_MEM32(0xF4)
+
 #define CANIDM4 _SFR_MEM8(0xF4)
 #define IDEMSK 0
 #define RTRMSK 2
diff -u ../avr-libc/trunk/avr-libc/include/avr/iotn43u.h /usr/local/avr/avr/include/avr/iotn43u.h
--- ../avr-libc/trunk/avr-libc/include/avr/iotn43u.h	2010-05-31 09:49:34.201324443 -0400
+++ /usr/local/avr/avr/include/avr/iotn43u.h	2010-07-28 15:23:22.815785437 -0400
@@ -74,7 +74,10 @@
 #define ADLAR  4
 #define ACME   6
 
-#define ADC _SFR_IO16(0x04)
+#ifndef _ASSEMBLER_ 
+#define ADC _SFR_MEM16(0x04) 
+#endif 
+#define ADCW _SFR_MEM16(0x04) 
 
 #define ADCL _SFR_IO8(0x04)
 #define ADCL0  0
diff -u ../avr-libc/trunk/avr-libc/include/avr/power.h /usr/local/avr/avr/include/avr/power.h
--- ../avr-libc/trunk/avr-libc/include/avr/power.h	2010-07-30 08:22:11.987221564 -0400
+++ /usr/local/avr/avr/include/avr/power.h	2010-07-30 08:19:46.847217363 -0400
@@ -1,4 +1,5 @@
 /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
+   Copyright (c) 2010 Frédéric Nadeau
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -1372,13 +1373,26 @@
 
 Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
 allows you to decrease the system clock frequency and the power consumption
-when the need for processing power is low. Below are two macros and an
-enumerated type that can be used to interface to the Clock Prescale Register.
+when the need for processing power is low.
 
-\note Not all AVR devices have a Clock Prescale Register. On those devices
-without a Clock Prescale Register, these macros are not available.
-*/
+Some devices have the XTAL Divide Control Register which offer similar
+functionnality than System Clock Prescale Register.
+
+Below are two macros and an enumerated type that can be used to interface to
+either the Clock Prescale Register or the XTAL Divide Control Register
+depending on your device capability.
+
+\note Not all AVR devices have a Clock Prescale Register or XTAL Divide Control
+Register. On those devices without a Clock Prescale Register or XTAL Divide
+Control Register, these macros are not available.
+
+\note For device using the XTAL Divide Control Register (XDIV), when prescaller
+is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
+that Timer/Counter0 source shall be less than ¼th of peripheral clock.
+Therefore, when using a typical 32.768 kHz, one shall not scale the clock
+below 131.072 khz.
 
+*/
 
 /** \addtogroup avr_power
 \code 
@@ -1396,7 +1410,24 @@
     clock_div_1_rc = 15, // ATmega128RFA1 only
 } clock_div_t;
 \endcode
-Clock prescaler setting enumerations.
+Clock prescaler setting enumerations for device with System Clock Prescale
+Register (CLKPR).
+
+\code
+typedef enum
+{
+    clock_div_1 = 1,
+    clock_div_2 = 2,
+    clock_div_4 = 4,
+    clock_div_8 = 8,
+    clock_div_16 = 16,
+    clock_div_32 = 32,
+    clock_div_64 = 64,
+    clock_div_128 = 128
+} clock_div_t;
+\endcode
+Clock prescaler setting enumerations for device with XTAL Divide Control
+Register (XDIV).
 
 */
 typedef enum
@@ -1426,6 +1457,11 @@
 optimizations are disabled.
 
 The type of x is clock_div_t.
+
+\note For device with XTAL Divide Control Register (XDIV), x can actually range
+from 1 to 129. Thus, one does not need to use clock_div_t type as argument.
+Remember that gcc will interprete enums as generic type, most likely as
+unsigned char here.
 */
 void clock_prescale_set(clock_div_t __x)
 {
@@ -1447,6 +1483,11 @@
 \code clock_prescale_get() \endcode
 Gets and returns the clock prescaler register setting. The return type is clock_div_t.
 
+\note For device with XTAL Divide Control Register (XDIV), return can actually
+range from 1 to 129. Thus, one does not need to use clock_div_t type as
+argument. Remember that gcc will interprete enums as generic type, most likely
+as unsigned char here.
+
 */
 #define clock_prescale_get()  (clock_div_t)(CLKPR & (uint8_t)((1<<CLKPS0)|(1<<CLKPS1)|(1<<CLKPS2)|(1<<CLKPS3)))
 
@@ -1506,10 +1547,89 @@
 
 #define clock_prescale_get()  (clock_div_t)(CLKPR & (uint8_t)((1<<CLKPS0)|(1<<CLKPS1)|(1<<CLKPS2)|(1<<CLKPS3)))
 
+#elif defined(__AVR_ATmega64__) \
+|| defined(__AVR_ATmega103__) \
+|| defined(__AVR_ATmega128__)
 
-#endif
+//Enum is declared for code compatibility
+typedef enum
+{
+    clock_div_1 = 1,
+    clock_div_2 = 2,
+    clock_div_4 = 4,
+    clock_div_8 = 8,
+    clock_div_16 = 16,
+    clock_div_32 = 32,
+    clock_div_64 = 64,
+    clock_div_128 = 128
+} clock_div_t;
 
+void clock_prescale_set(clock_div_t __x)
+{
+    if((__x <= 0) || (__x > 129))
+    {
+        return;//Invalid value.
+    }
+    else
+        {
+        uint8_t __tmp = 0;
+        //Algo explained:
+        //1 - Clear XDIV in order for it to accept a new value (actually only
+        //    XDIVEN need to be cleared, but clearing XDIV is faster than
+        //    read-modify-write since we will rewrite XDIV later anyway)
+        //2 - wait 8 clock cycle for stability, see datasheet erreta
+        //3 - Exist if requested prescaller is 1
+        //4 - Calculate XDIV6..0 value = 129 - __x
+        //5 - Set XDIVEN bit in calculated value
+        //6 - write XDIV with calculated value
+        //7 - wait 8 clock cycle for stability, see datasheet erreta
+        __asm__ __volatile__ (
+            "in __tmp_reg__,__SREG__" "\n\t"
+            "cli" "\n\t"
+            "out %1, __zero_reg__" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "cpi %0, 0x01" "\n\t"
+            "breq L_%=" "\n\t"
+            "ldi %2, 0x81" "\n\t" //129
+            "sub %2, %0" "\n\t"
+            "ori %2, 0x80" "\n\t" //128
+            "out %1, %2" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "nop" "\n\t"
+            "L_%=: " "out __SREG__, __tmp_reg__"
+            : /* no outputs */
+            :"d" (__x),
+             "I" (_SFR_IO_ADDR(XDIV)),
+             "d" (__tmp)
+            : "r0");
+        }
+}
 
+clock_div_t clock_prescale_get(void)
+{
+    if(bit_is_clear(XDIV, XDIVEN))
+    {
+        return 1;
+    }
+    else
+    {
+        return (clock_div_t)(129 - (XDIV & 0x7F));
+    }
+}
 
+#endif
 
 #endif /* _AVR_POWER_H_ */
